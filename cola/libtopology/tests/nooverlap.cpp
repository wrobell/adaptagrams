/**
 * Test of topology conserving constraints - no overlap constraints.
 * A number of rectangles is generated and overlaps between them 
 * removed using libvpsc.  For each drawing dimension dim,
 * an instance of TopologyConstraints 
 * in axis dim is generated for this set of non-overlapping rectangles and
 * hence a set of libvpsc::Constraints that should prevent overlap
 * if the rectangles move in dim.  The rectangles are then randomly perturbed in
 * dim and overlaps resolved again using libvpsc with the set of constraints
 * generated by TopologyConstraints.
 * Overlaps must then be non-existent.
 *
 * \file nooverlap.cpp
 * \author Tim Dwyer
 * \date Jan 2008
 */
#include <libvpsc/rectangle.h>
#include <libtopology/topology_constraints.h>
#include <libcola/cola.h>
#include <libcola/output_svg.h>
#include <libvpsc/variable.h>
#include <libvpsc/constraint.h>
#include <vector>
#include <iostream>
#include <sstream>
using namespace std;
using namespace topology;
#include "test.h"
struct Create {
    Create() : ctr(0) {}
    Node* operator() (vpsc::Rectangle* r) {
        return new Node(ctr++,r);
    }
    vpsc::Variable* operator() (Node* v) {
        return new vpsc::Variable(v->id);
    }
    unsigned ctr;
};
void randomTest() {
    string name("nooverlap");
    vpsc::Rectangles rs;
    const size_t V = 10;
    generateRandomRects(V,rs);
    removeoverlaps(rs);
    assertNoOverlaps(rs);
    Nodes nodes(V);
    transform(rs.begin(),rs.end(),nodes.begin(),Create());

    //writeFile(nodes,es,name+"-0.svg");

    vpsc::Variables vs(V);
    transform(nodes.begin(),nodes.end(),vs.begin(),Create());

    for(int dim=0;dim<2;dim++) {
        vpsc::Constraints cs;
        Edges es; // not used in this test
        TopologyConstraints t(static_cast<cola::Dim>(dim),nodes,es,vs,cs);
        for(unsigned i=0;i<V;++i) {
            vpsc::Rectangle* r=rs[i];
            r->moveCentreD(dim,getRand(5));
            vs[i]->desiredPosition=r->getCentreD(dim);
        }
        //writeFile(nodes,es,name+"-1.svg");
        vpsc::Solver vpsc(vs,cs);
        vpsc.solve();
        vpsc::Variables::iterator j=vs.begin();
        for(unsigned i=0;i<V;++i) {
            vpsc::Rectangle* r=rs[i];
            r->moveCentreD(dim,vs[i]->finalPosition);
        }

        //writeFile(nodes,es,name+"-2.svg");
        assertNoOverlaps(rs);
        for_each(cs.begin(),cs.end(),delete_object());
    }

    for_each(vs.begin(),vs.end(),delete_object());
    for_each(nodes.begin(),nodes.end(),delete_object());
    for_each(rs.begin(),rs.end(),delete_object());
}

int main() {
    for(unsigned i=0;i<10000;++i) {
        if(!(i%1000)) {
            printf(" completed %d instances...\n",i);
        }
        randomTest();
    }
    return 0;
}
// vim: filetype=cpp:expandtab:shiftwidth=4:tabstop=4:softtabstop=4:encoding=utf-8:textwidth=80 :
